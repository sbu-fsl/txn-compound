// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: secnfs.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "secnfs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace secnfs {

namespace {

const ::google::protobuf::Descriptor* FileHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileMeta_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileMeta_reflection_ = NULL;
const ::google::protobuf::Descriptor* Range_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Range_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyFile_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyBlock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyBlock_reflection_ = NULL;
const ::google::protobuf::Descriptor* SecureContextConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SecureContextConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProxyList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProxyList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProxyEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProxyEntry_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_secnfs_2eproto() {
  protobuf_AddDesc_secnfs_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "secnfs.proto");
  GOOGLE_CHECK(file != NULL);
  FileHeader_descriptor_ = file->message_type(0);
  static const int FileHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, keyfile_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, meta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, version_),
  };
  FileHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileHeader_descriptor_,
      FileHeader::default_instance_,
      FileHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileHeader));
  FileMeta_descriptor_ = file->message_type(1);
  static const int FileMeta_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, filesize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, encrypted_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, holes_),
  };
  FileMeta_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileMeta_descriptor_,
      FileMeta::default_instance_,
      FileMeta_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileMeta));
  Range_descriptor_ = file->message_type(2);
  static const int Range_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, length_),
  };
  Range_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Range_descriptor_,
      Range::default_instance_,
      Range_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Range));
  KeyFile_descriptor_ = file->message_type(3);
  static const int KeyFile_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, creator_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, key_blocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, signature_),
  };
  KeyFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyFile_descriptor_,
      KeyFile::default_instance_,
      KeyFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyFile));
  KeyBlock_descriptor_ = file->message_type(4);
  static const int KeyBlock_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, proxy_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, encrypted_key_),
  };
  KeyBlock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyBlock_descriptor_,
      KeyBlock::default_instance_,
      KeyBlock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyBlock));
  SecureContextConfig_descriptor_ = file->message_type(5);
  static const int SecureContextConfig_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, pub_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, pri_key_),
  };
  SecureContextConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SecureContextConfig_descriptor_,
      SecureContextConfig::default_instance_,
      SecureContextConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SecureContextConfig));
  ProxyList_descriptor_ = file->message_type(6);
  static const int ProxyList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyList, proxies_),
  };
  ProxyList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProxyList_descriptor_,
      ProxyList::default_instance_,
      ProxyList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProxyList));
  ProxyEntry_descriptor_ = file->message_type(7);
  static const int ProxyEntry_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, key_),
  };
  ProxyEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProxyEntry_descriptor_,
      ProxyEntry::default_instance_,
      ProxyEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProxyEntry));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_secnfs_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileHeader_descriptor_, &FileHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileMeta_descriptor_, &FileMeta::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Range_descriptor_, &Range::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyFile_descriptor_, &KeyFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyBlock_descriptor_, &KeyBlock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SecureContextConfig_descriptor_, &SecureContextConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProxyList_descriptor_, &ProxyList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProxyEntry_descriptor_, &ProxyEntry::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_secnfs_2eproto() {
  delete FileHeader::default_instance_;
  delete FileHeader_reflection_;
  delete FileMeta::default_instance_;
  delete FileMeta_reflection_;
  delete Range::default_instance_;
  delete Range_reflection_;
  delete KeyFile::default_instance_;
  delete KeyFile_reflection_;
  delete KeyBlock::default_instance_;
  delete KeyBlock_reflection_;
  delete SecureContextConfig::default_instance_;
  delete SecureContextConfig_reflection_;
  delete ProxyList::default_instance_;
  delete ProxyList_reflection_;
  delete ProxyEntry::default_instance_;
  delete ProxyEntry_reflection_;
}

void protobuf_AddDesc_secnfs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014secnfs.proto\022\006secnfs\"M\n\nFileHeader\022 \n\007"
    "keyfile\030\001 \002(\0132\017.secnfs.KeyFile\022\014\n\004meta\030\002"
    " \001(\014\022\017\n\007version\030\003 \001(\014\"M\n\010FileMeta\022\020\n\010fil"
    "esize\030\001 \001(\004\022\021\n\tencrypted\030\002 \001(\010\022\034\n\005holes\030"
    "\003 \003(\0132\r.secnfs.Range\"\'\n\005Range\022\016\n\006offset\030"
    "\001 \002(\004\022\016\n\006length\030\002 \002(\004\"_\n\007KeyFile\022\017\n\007crea"
    "tor\030\001 \002(\t\022\n\n\002iv\030\002 \002(\014\022$\n\nkey_blocks\030\003 \003("
    "\0132\020.secnfs.KeyBlock\022\021\n\tsignature\030\004 \001(\014\"5"
    "\n\010KeyBlock\022\022\n\nproxy_name\030\001 \002(\t\022\025\n\rencryp"
    "ted_key\030\002 \002(\014\"E\n\023SecureContextConfig\022\014\n\004"
    "name\030\001 \002(\t\022\017\n\007pub_key\030\002 \002(\014\022\017\n\007pri_key\030\003"
    " \002(\014\"0\n\tProxyList\022#\n\007proxies\030\001 \003(\0132\022.sec"
    "nfs.ProxyEntry\"\'\n\nProxyEntry\022\014\n\004name\030\001 \002"
    "(\t\022\013\n\003key\030\002 \002(\014", 535);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "secnfs.proto", &protobuf_RegisterTypes);
  FileHeader::default_instance_ = new FileHeader();
  FileMeta::default_instance_ = new FileMeta();
  Range::default_instance_ = new Range();
  KeyFile::default_instance_ = new KeyFile();
  KeyBlock::default_instance_ = new KeyBlock();
  SecureContextConfig::default_instance_ = new SecureContextConfig();
  ProxyList::default_instance_ = new ProxyList();
  ProxyEntry::default_instance_ = new ProxyEntry();
  FileHeader::default_instance_->InitAsDefaultInstance();
  FileMeta::default_instance_->InitAsDefaultInstance();
  Range::default_instance_->InitAsDefaultInstance();
  KeyFile::default_instance_->InitAsDefaultInstance();
  KeyBlock::default_instance_->InitAsDefaultInstance();
  SecureContextConfig::default_instance_->InitAsDefaultInstance();
  ProxyList::default_instance_->InitAsDefaultInstance();
  ProxyEntry::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_secnfs_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_secnfs_2eproto {
  StaticDescriptorInitializer_secnfs_2eproto() {
    protobuf_AddDesc_secnfs_2eproto();
  }
} static_descriptor_initializer_secnfs_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int FileHeader::kKeyfileFieldNumber;
const int FileHeader::kMetaFieldNumber;
const int FileHeader::kVersionFieldNumber;
#endif  // !_MSC_VER

FileHeader::FileHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileHeader::InitAsDefaultInstance() {
  keyfile_ = const_cast< ::secnfs::KeyFile*>(&::secnfs::KeyFile::default_instance());
}

FileHeader::FileHeader(const FileHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileHeader::SharedCtor() {
  _cached_size_ = 0;
  keyfile_ = NULL;
  meta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileHeader::~FileHeader() {
  SharedDtor();
}

void FileHeader::SharedDtor() {
  if (meta_ != &::google::protobuf::internal::kEmptyString) {
    delete meta_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
    delete keyfile_;
  }
}

void FileHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileHeader_descriptor_;
}

const FileHeader& FileHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

FileHeader* FileHeader::default_instance_ = NULL;

FileHeader* FileHeader::New() const {
  return new FileHeader;
}

void FileHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_keyfile()) {
      if (keyfile_ != NULL) keyfile_->::secnfs::KeyFile::Clear();
    }
    if (has_meta()) {
      if (meta_ != &::google::protobuf::internal::kEmptyString) {
        meta_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .secnfs.KeyFile keyfile = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keyfile()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_meta;
        break;
      }

      // optional bytes meta = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_meta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_meta()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }

      // optional bytes version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .secnfs.KeyFile keyfile = 1;
  if (has_keyfile()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->keyfile(), output);
  }

  // optional bytes meta = 2;
  if (has_meta()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->meta(), output);
  }

  // optional bytes version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .secnfs.KeyFile keyfile = 1;
  if (has_keyfile()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->keyfile(), target);
  }

  // optional bytes meta = 2;
  if (has_meta()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->meta(), target);
  }

  // optional bytes version = 3;
  if (has_version()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .secnfs.KeyFile keyfile = 1;
    if (has_keyfile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keyfile());
    }

    // optional bytes meta = 2;
    if (has_meta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->meta());
    }

    // optional bytes version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileHeader::MergeFrom(const FileHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keyfile()) {
      mutable_keyfile()->::secnfs::KeyFile::MergeFrom(from.keyfile());
    }
    if (from.has_meta()) {
      set_meta(from.meta());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileHeader::CopyFrom(const FileHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_keyfile()) {
    if (!this->keyfile().IsInitialized()) return false;
  }
  return true;
}

void FileHeader::Swap(FileHeader* other) {
  if (other != this) {
    std::swap(keyfile_, other->keyfile_);
    std::swap(meta_, other->meta_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileHeader_descriptor_;
  metadata.reflection = FileHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileMeta::kFilesizeFieldNumber;
const int FileMeta::kEncryptedFieldNumber;
const int FileMeta::kHolesFieldNumber;
#endif  // !_MSC_VER

FileMeta::FileMeta()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileMeta::InitAsDefaultInstance() {
}

FileMeta::FileMeta(const FileMeta& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileMeta::SharedCtor() {
  _cached_size_ = 0;
  filesize_ = GOOGLE_ULONGLONG(0);
  encrypted_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileMeta::~FileMeta() {
  SharedDtor();
}

void FileMeta::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileMeta::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileMeta::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileMeta_descriptor_;
}

const FileMeta& FileMeta::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

FileMeta* FileMeta::default_instance_ = NULL;

FileMeta* FileMeta::New() const {
  return new FileMeta;
}

void FileMeta::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    filesize_ = GOOGLE_ULONGLONG(0);
    encrypted_ = false;
  }
  holes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileMeta::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 filesize = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &filesize_)));
          set_has_filesize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_encrypted;
        break;
      }

      // optional bool encrypted = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encrypted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &encrypted_)));
          set_has_encrypted();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_holes;
        break;
      }

      // repeated .secnfs.Range holes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_holes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_holes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_holes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileMeta::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 filesize = 1;
  if (has_filesize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->filesize(), output);
  }

  // optional bool encrypted = 2;
  if (has_encrypted()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->encrypted(), output);
  }

  // repeated .secnfs.Range holes = 3;
  for (int i = 0; i < this->holes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->holes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileMeta::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 filesize = 1;
  if (has_filesize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->filesize(), target);
  }

  // optional bool encrypted = 2;
  if (has_encrypted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->encrypted(), target);
  }

  // repeated .secnfs.Range holes = 3;
  for (int i = 0; i < this->holes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->holes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileMeta::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 filesize = 1;
    if (has_filesize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->filesize());
    }

    // optional bool encrypted = 2;
    if (has_encrypted()) {
      total_size += 1 + 1;
    }

  }
  // repeated .secnfs.Range holes = 3;
  total_size += 1 * this->holes_size();
  for (int i = 0; i < this->holes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->holes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileMeta::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileMeta* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileMeta*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileMeta::MergeFrom(const FileMeta& from) {
  GOOGLE_CHECK_NE(&from, this);
  holes_.MergeFrom(from.holes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filesize()) {
      set_filesize(from.filesize());
    }
    if (from.has_encrypted()) {
      set_encrypted(from.encrypted());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileMeta::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileMeta::CopyFrom(const FileMeta& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileMeta::IsInitialized() const {

  for (int i = 0; i < holes_size(); i++) {
    if (!this->holes(i).IsInitialized()) return false;
  }
  return true;
}

void FileMeta::Swap(FileMeta* other) {
  if (other != this) {
    std::swap(filesize_, other->filesize_);
    std::swap(encrypted_, other->encrypted_);
    holes_.Swap(&other->holes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileMeta::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileMeta_descriptor_;
  metadata.reflection = FileMeta_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Range::kOffsetFieldNumber;
const int Range::kLengthFieldNumber;
#endif  // !_MSC_VER

Range::Range()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Range::InitAsDefaultInstance() {
}

Range::Range(const Range& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Range::SharedCtor() {
  _cached_size_ = 0;
  offset_ = GOOGLE_ULONGLONG(0);
  length_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Range::~Range() {
  SharedDtor();
}

void Range::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Range::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Range::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Range_descriptor_;
}

const Range& Range::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

Range* Range::default_instance_ = NULL;

Range* Range::New() const {
  return new Range;
}

void Range::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    offset_ = GOOGLE_ULONGLONG(0);
    length_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Range::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 offset = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_length;
        break;
      }

      // required uint64 length = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Range::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 offset = 1;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->offset(), output);
  }

  // required uint64 length = 2;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->length(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Range::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 offset = 1;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->offset(), target);
  }

  // required uint64 length = 2;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->length(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Range::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

    // required uint64 length = 2;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->length());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Range::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Range* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Range*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Range::MergeFrom(const Range& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Range::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Range::CopyFrom(const Range& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Range::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Range::Swap(Range* other) {
  if (other != this) {
    std::swap(offset_, other->offset_);
    std::swap(length_, other->length_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Range::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Range_descriptor_;
  metadata.reflection = Range_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyFile::kCreatorFieldNumber;
const int KeyFile::kIvFieldNumber;
const int KeyFile::kKeyBlocksFieldNumber;
const int KeyFile::kSignatureFieldNumber;
#endif  // !_MSC_VER

KeyFile::KeyFile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyFile::InitAsDefaultInstance() {
}

KeyFile::KeyFile(const KeyFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyFile::SharedCtor() {
  _cached_size_ = 0;
  creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyFile::~KeyFile() {
  SharedDtor();
}

void KeyFile::SharedDtor() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_;
  }
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void KeyFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyFile_descriptor_;
}

const KeyFile& KeyFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

KeyFile* KeyFile::default_instance_ = NULL;

KeyFile* KeyFile::New() const {
  return new KeyFile;
}

void KeyFile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_creator()) {
      if (creator_ != &::google::protobuf::internal::kEmptyString) {
        creator_->clear();
      }
    }
    if (has_iv()) {
      if (iv_ != &::google::protobuf::internal::kEmptyString) {
        iv_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
  }
  key_blocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string creator = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_creator()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->creator().data(), this->creator().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iv;
        break;
      }

      // required bytes iv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_blocks;
        break;
      }

      // repeated .secnfs.KeyBlock key_blocks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_blocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_blocks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_blocks;
        if (input->ExpectTag(34)) goto parse_signature;
        break;
      }

      // optional bytes signature = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string creator = 1;
  if (has_creator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->creator().data(), this->creator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->creator(), output);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->iv(), output);
  }

  // repeated .secnfs.KeyBlock key_blocks = 3;
  for (int i = 0; i < this->key_blocks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->key_blocks(i), output);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string creator = 1;
  if (has_creator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->creator().data(), this->creator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->creator(), target);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->iv(), target);
  }

  // repeated .secnfs.KeyBlock key_blocks = 3;
  for (int i = 0; i < this->key_blocks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->key_blocks(i), target);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyFile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string creator = 1;
    if (has_creator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->creator());
    }

    // required bytes iv = 2;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

    // optional bytes signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  // repeated .secnfs.KeyBlock key_blocks = 3;
  total_size += 1 * this->key_blocks_size();
  for (int i = 0; i < this->key_blocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_blocks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyFile::MergeFrom(const KeyFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_blocks_.MergeFrom(from.key_blocks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_creator()) {
      set_creator(from.creator());
    }
    if (from.has_iv()) {
      set_iv(from.iv());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyFile::CopyFrom(const KeyFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < key_blocks_size(); i++) {
    if (!this->key_blocks(i).IsInitialized()) return false;
  }
  return true;
}

void KeyFile::Swap(KeyFile* other) {
  if (other != this) {
    std::swap(creator_, other->creator_);
    std::swap(iv_, other->iv_);
    key_blocks_.Swap(&other->key_blocks_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyFile_descriptor_;
  metadata.reflection = KeyFile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyBlock::kProxyNameFieldNumber;
const int KeyBlock::kEncryptedKeyFieldNumber;
#endif  // !_MSC_VER

KeyBlock::KeyBlock()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyBlock::InitAsDefaultInstance() {
}

KeyBlock::KeyBlock(const KeyBlock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyBlock::SharedCtor() {
  _cached_size_ = 0;
  proxy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encrypted_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyBlock::~KeyBlock() {
  SharedDtor();
}

void KeyBlock::SharedDtor() {
  if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete proxy_name_;
  }
  if (encrypted_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_key_;
  }
  if (this != default_instance_) {
  }
}

void KeyBlock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyBlock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyBlock_descriptor_;
}

const KeyBlock& KeyBlock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

KeyBlock* KeyBlock::default_instance_ = NULL;

KeyBlock* KeyBlock::New() const {
  return new KeyBlock;
}

void KeyBlock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_proxy_name()) {
      if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
        proxy_name_->clear();
      }
    }
    if (has_encrypted_key()) {
      if (encrypted_key_ != &::google::protobuf::internal::kEmptyString) {
        encrypted_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyBlock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string proxy_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_proxy_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->proxy_name().data(), this->proxy_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encrypted_key;
        break;
      }

      // required bytes encrypted_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyBlock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string proxy_name = 1;
  if (has_proxy_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->proxy_name().data(), this->proxy_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->proxy_name(), output);
  }

  // required bytes encrypted_key = 2;
  if (has_encrypted_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->encrypted_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyBlock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string proxy_name = 1;
  if (has_proxy_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->proxy_name().data(), this->proxy_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->proxy_name(), target);
  }

  // required bytes encrypted_key = 2;
  if (has_encrypted_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->encrypted_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyBlock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string proxy_name = 1;
    if (has_proxy_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->proxy_name());
    }

    // required bytes encrypted_key = 2;
    if (has_encrypted_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyBlock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyBlock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyBlock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyBlock::MergeFrom(const KeyBlock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_proxy_name()) {
      set_proxy_name(from.proxy_name());
    }
    if (from.has_encrypted_key()) {
      set_encrypted_key(from.encrypted_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyBlock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyBlock::CopyFrom(const KeyBlock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyBlock::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void KeyBlock::Swap(KeyBlock* other) {
  if (other != this) {
    std::swap(proxy_name_, other->proxy_name_);
    std::swap(encrypted_key_, other->encrypted_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyBlock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyBlock_descriptor_;
  metadata.reflection = KeyBlock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SecureContextConfig::kNameFieldNumber;
const int SecureContextConfig::kPubKeyFieldNumber;
const int SecureContextConfig::kPriKeyFieldNumber;
#endif  // !_MSC_VER

SecureContextConfig::SecureContextConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SecureContextConfig::InitAsDefaultInstance() {
}

SecureContextConfig::SecureContextConfig(const SecureContextConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SecureContextConfig::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pri_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SecureContextConfig::~SecureContextConfig() {
  SharedDtor();
}

void SecureContextConfig::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pub_key_;
  }
  if (pri_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pri_key_;
  }
  if (this != default_instance_) {
  }
}

void SecureContextConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SecureContextConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SecureContextConfig_descriptor_;
}

const SecureContextConfig& SecureContextConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

SecureContextConfig* SecureContextConfig::default_instance_ = NULL;

SecureContextConfig* SecureContextConfig::New() const {
  return new SecureContextConfig;
}

void SecureContextConfig::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_pub_key()) {
      if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
        pub_key_->clear();
      }
    }
    if (has_pri_key()) {
      if (pri_key_ != &::google::protobuf::internal::kEmptyString) {
        pri_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SecureContextConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pub_key;
        break;
      }

      // required bytes pub_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pub_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pub_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pri_key;
        break;
      }

      // required bytes pri_key = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pri_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pri_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SecureContextConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required bytes pub_key = 2;
  if (has_pub_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->pub_key(), output);
  }

  // required bytes pri_key = 3;
  if (has_pri_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->pri_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SecureContextConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required bytes pub_key = 2;
  if (has_pub_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->pub_key(), target);
  }

  // required bytes pri_key = 3;
  if (has_pri_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->pri_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SecureContextConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required bytes pub_key = 2;
    if (has_pub_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pub_key());
    }

    // required bytes pri_key = 3;
    if (has_pri_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pri_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SecureContextConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SecureContextConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SecureContextConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SecureContextConfig::MergeFrom(const SecureContextConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_pub_key()) {
      set_pub_key(from.pub_key());
    }
    if (from.has_pri_key()) {
      set_pri_key(from.pri_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SecureContextConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SecureContextConfig::CopyFrom(const SecureContextConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecureContextConfig::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void SecureContextConfig::Swap(SecureContextConfig* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(pub_key_, other->pub_key_);
    std::swap(pri_key_, other->pri_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SecureContextConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SecureContextConfig_descriptor_;
  metadata.reflection = SecureContextConfig_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProxyList::kProxiesFieldNumber;
#endif  // !_MSC_VER

ProxyList::ProxyList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProxyList::InitAsDefaultInstance() {
}

ProxyList::ProxyList(const ProxyList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProxyList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProxyList::~ProxyList() {
  SharedDtor();
}

void ProxyList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProxyList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProxyList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProxyList_descriptor_;
}

const ProxyList& ProxyList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

ProxyList* ProxyList::default_instance_ = NULL;

ProxyList* ProxyList::New() const {
  return new ProxyList;
}

void ProxyList::Clear() {
  proxies_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProxyList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .secnfs.ProxyEntry proxies = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proxies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_proxies()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_proxies;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProxyList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .secnfs.ProxyEntry proxies = 1;
  for (int i = 0; i < this->proxies_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->proxies(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProxyList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .secnfs.ProxyEntry proxies = 1;
  for (int i = 0; i < this->proxies_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->proxies(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProxyList::ByteSize() const {
  int total_size = 0;

  // repeated .secnfs.ProxyEntry proxies = 1;
  total_size += 1 * this->proxies_size();
  for (int i = 0; i < this->proxies_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->proxies(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProxyList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProxyList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProxyList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProxyList::MergeFrom(const ProxyList& from) {
  GOOGLE_CHECK_NE(&from, this);
  proxies_.MergeFrom(from.proxies_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProxyList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProxyList::CopyFrom(const ProxyList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProxyList::IsInitialized() const {

  for (int i = 0; i < proxies_size(); i++) {
    if (!this->proxies(i).IsInitialized()) return false;
  }
  return true;
}

void ProxyList::Swap(ProxyList* other) {
  if (other != this) {
    proxies_.Swap(&other->proxies_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProxyList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProxyList_descriptor_;
  metadata.reflection = ProxyList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProxyEntry::kNameFieldNumber;
const int ProxyEntry::kKeyFieldNumber;
#endif  // !_MSC_VER

ProxyEntry::ProxyEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProxyEntry::InitAsDefaultInstance() {
}

ProxyEntry::ProxyEntry(const ProxyEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProxyEntry::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProxyEntry::~ProxyEntry() {
  SharedDtor();
}

void ProxyEntry::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

void ProxyEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProxyEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProxyEntry_descriptor_;
}

const ProxyEntry& ProxyEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

ProxyEntry* ProxyEntry::default_instance_ = NULL;

ProxyEntry* ProxyEntry::New() const {
  return new ProxyEntry;
}

void ProxyEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProxyEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // required bytes key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProxyEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required bytes key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProxyEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required bytes key = 2;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProxyEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required bytes key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProxyEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProxyEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProxyEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProxyEntry::MergeFrom(const ProxyEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProxyEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProxyEntry::CopyFrom(const ProxyEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProxyEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ProxyEntry::Swap(ProxyEntry* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProxyEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProxyEntry_descriptor_;
  metadata.reflection = ProxyEntry_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace secnfs

// @@protoc_insertion_point(global_scope)
